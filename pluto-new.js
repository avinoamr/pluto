(function(){
/**
 * PLUTO
 * Native HTML Template Rendering
 *
 *
 * The MIT License (MIT)
 * Copyright (c) 2013 Roi Avinoam
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
class Template extends HTMLTemplateElement {
    render(obj) {
        var cloned = pluto(this.cloneNode(true))
        cloned.removeAttribute('id')

        cloned.compile()
        var doc = new RepeatRenderer(cloned)
        doc.appendChild(cloned)
        return doc.render(obj)
    }

    compile() {
        var exprs = []
        var els = [{ el: this.content, path: [] }]
        while (els.length > 0) {
            var { el, path } = els.shift()

            // enqueue child nodes
            el.childNodes.forEach(function(el, i) {
                var subpath = path.concat(['childNodes', i])
                els.push({ el: el, path: subpath })
            })

            // text node expressions
            if (el.nodeName === '#text') {
                var expr = isExpressions(el.textContent)
                if (expr) {
                    exprs.push({ expr, path })
                }
            }

            // attribute expressions
            Array.from(el.attributes || []).forEach(function (attr) {
                var expr = isExpressions(attr.value)
                if (expr !== null) {
                    var attr = snakeToCamelCase(attr.name)
                    exprs.push({ expr, path, attr })
                }
            })
        }

        this._exprs = Object.assign(exprs, { eval: compileExpressions(exprs) })
    }
}

class RepeatRenderer extends DocumentFragment {
    constructor(tpl) {
        super()
        this._tpl = tpl
        this._exprs = tpl._exprs
        console.log(this._tpl.repeat)
        this.repeat = ['three', 'four']
    }

    render(obj) {
        this.repeat.forEach(function(item) {
            obj.item = item
            var doc = this.renderOne(obj)
            this._tpl.before(doc)
        }, this)

        return this
    }

    renderOne(obj) {
        var doc = document.importNode(this._tpl.content, true)
        doc.hardLinks = []

        // generate hard links to the elements generated by this renderer
        var deferred = []
        for (var i = 0; i < this._exprs.length; i += 1) {
            var expr = this._exprs[i]
            var el = select(doc, expr.path)
            doc.hardLinks[i] = el

            // if (el.localName === 'template') {
            //     pluto(el).compile()
            //     console.log('h  ')
            //     var subdoc = new RepeatRenderer(el)
            //     // var subdoc = pluto(el).render(obj)
            //     // deferred.push(el.before.bind(el, subdoc))
            // }
        }

        var values = this._exprs.eval(obj)
        for (var i = 0; i < this._exprs.length; i += 1) {
            var expr = this._exprs[i]
            var el = doc.hardLinks[i]
            if (!expr.attr) {
                el.textContent = values[i]
                continue
            }

            el[expr.attr] = values[i]

            if (el.localName === 'template') {
                console.log(el.repeat)
            }
        }

        return doc
    }
}

class Renderer extends DocumentFragment {
    constructor(tpl) {
        super()
        this._tpl = tpl
        this._exprs = tpl._exprs
        this.hardLinks = []
    }

    init(obj) {
        this.appendChild(document.importNode(this._tpl.content, true))

        // generate hard links to the elements generated by this renderer
        var deferred = []
        for (var i = 0; i < this._exprs.length; i += 1) {
            var expr = this._exprs[i]
            var el = select(this, expr.path)

            // nested template
            if (el.localName === 'template') {
                var sub = pluto(el).render(obj)
                deferred.push(el.parentNode.insertBefore.bind(el.parentNode, sub, el))
                el = sub
            }

            this.hardLinks[i] = el
        }

        deferred.forEach((fn) => fn())
    }

    render(obj) {
        if (!this._inited) {
            this._inited = true
            this.init(obj)
        }

        var values = this._exprs.eval(obj)
        for (var i = 0; i < this._exprs.length; i += 1) {
            var expr = this._exprs[i]
            var el = this.hardLinks[i]

            if (!expr.attr) {
                el.textContent = values[i]
                continue
            }

            el[expr.attr] = values[i]

            if (el.render) {
                el.render(obj)
            }
        }

        return this
    }
}

function select(root, path) {
    var current = root
    for (var i = 0; current !== undefined && i < path.length; i += 1) {
        current = current[path[i]]
    }
    return current
}

const SNAKE_RE = /-([a-z])/g
function snakeToCamelCase(s) {
    return s.replace(SNAKE_RE, g => g[1].toUpperCase())
}

// extract expressions in template-literal syntax out of a string
var EXPR_RE = /\$\{[^\}]*\}/
function isExpressions(s) {
    return EXPR_RE.test(s) ? s : null
}

// compile a list of template-literal expressions into a function that evaluates
// these expression for the provided input object
function compileExpressions(exprs) {
    function T(s, v) {
        return arguments.length > 2 || typeof v === 'string'
            ? String.raw.apply(null, arguments)
            : v
    }

    var code = exprs.map(function(expr, i) {
        return `this[${i}] = T\`${expr.expr}\``
    }).join(';\n')

    var keys = {}
    var fn = null
    return function(obj) {
        // check if the expressions function needs to be re-evaluated - only
        // when new keys exists on the input object that needs to be evaluated
        // as local variables. Generally - as long as the object doesn't add new
        // keys on every rerender, the function will be reevaluated infrequently
        var reEval = Object.keys(obj).reduce(function (reEval, k) {
            return keys[k] ? reEval : (keys[k] = true)
        }, fn === null)

        if (reEval) {
            var locals = `var { ${Object.keys(keys)} } = arguments[0];`
            fn = eval('(function () {\n' + locals + '\n' + code + '\n})')
        }

        var res = []
        fn.call(res, obj)
        return res
    }
}

// upgrade an element
// NOTE this will be unnecessary with customElements
function pluto(el) {
    if (typeof el === 'string') {
        // support HTML-imported selections
        var doc = document._currentScript // used by pollyfills
            || document.currentScript // native.
            || document // not an import.
        el = (doc.ownerDocument || doc).querySelector(el)
    }

    return !el || el instanceof Template
        ? el
        : Object.setPrototypeOf(el, Template.prototype)
}

pluto.Template = Template

window.pluto = pluto
})();
